## Module CV (Tab 2)

#####-------------------- UI RELATED FUNCTIONS ----------------------------------#####

# write either a list of params %in% which the value must be or a funciton using x
## ATENTION, THIS LIST MUST CONTAIN ALL IDS FROM THE BELOW TAGLIST, EVEN IF ITS NOT CHECKED (THEN WRITE NULL)
get_letter_checks <- function(){
  list(
    company_address = list(fnc = "nchar(x)>3 & nchar(x)<300", txt = "Company name 1 must be between 3 and 300 characters"),

    letter_title = list(fnc = "nchar(x)>10 & nchar(x)<50", txt = "Title line name 1 must be between 3 and 50 characters"),
    concern = list(fnc = "nchar(x)>10 & nchar(x)<70", txt = "Title line name 1 must be between 3 and 70 characters"),
    
    intro = list(fnc = "nchar(x)>180 & nchar(x)<650", txt = "Your resume must be between 180 and 650 characters"),
    main = list(fnc = "nchar(x)>180 & nchar(x)<600", txt = "Your situation must be between 180 and 600 characters"),
    company = list(fnc = "nchar(x)>120 & nchar(x)<450", txt = "Company part must be between 120 and 450 characters"),
    final = list(fnc = "nchar(x)>30 & nchar(x)<180", txt = "Conclusion must be between 30 and 180 characters")
  )
}

# form for inputs
letter_ui_form <- function(ns, params){
  tagList(
    tags$hr(),
    txt_area_3line(ns, "company_address", "Company Address"),
    tags$hr(),
    txt_area_1line(ns, "letter_title", "Letter Title"),
    txt_area_1line(ns, "concern", "Concern"),
    tags$hr(),
    txt_area_6line(ns, "intro", "Your resume"),
    txt_area_6line(ns, "main", "Your situation"),
    txt_area_6line(ns, "company", "Why you want to work for this company"),
    txt_area_6line(ns, "final", "Conclusion"),
    tags$hr()
  )
} 

# REnders the ui elements ready
letter_reset <- function(session, params, r_data, r_control){

  if ( r_data$job_data$language == "en"){
    updateTextAreaInput(session, "letter_title", value = paste("Application as a", r_data$letter_data$text$job_title))
  } else if (r_data$job_data$language == "de"){
    updateTextAreaInput(session, "letter_title", value = paste("Bewerbung als", r_data$letter_data$text$job_title))
  } else if (r_data$job_data$language == "pt"){
    updateTextAreaInput(session, "letter_title", value = paste("Application as a", r_data$letter_data$text$job_title))
  } else {
    updateTextAreaInput(session, "letter_title", value = r_data$letter_data$text$job_title)
                        
  }
    
  
  
  # address part
  updateTextAreaInput(session, "company_address", value = r_data$letter_data$text$company_address)
  
  # Title part
  updateTextAreaInput(session, "concern", value = r_data$letter_data$text$concern)
  
  # text part
  updateTextAreaInput(session, "intro", value = r_data$letter_data$text$intro)
  updateTextAreaInput(session, "main", value = r_data$letter_data$text$main)
  updateTextAreaInput(session, "company", value = r_data$letter_data$text$company)
  updateTextAreaInput(session, "final", value = r_data$letter_data$text$final)
  
  
  
  # reset reactives
  # r_data$cv_data = NULL
  # r_data$letter_data = NULL
  
  # control reset
  #r_control$ready_cv <- FALSE
  r_control$ready_letter <- FALSE

  # returns the text
  set_ui_ready(session = session, params = params, "Here is your Letter generated by GPT. You can adjust it")
}


#####-------------------- SERVER RELATED FUNCTIONS ----------------------------------#####

## CAPTURE VALUES ---------

# finally collect the inputs for cv
collect_letter_data <- function(input_vec){

  text_data <- list(
    company_address = input_vec$company_address,
    letter_title = input_vec$letter_title,
    concern = input_vec$concern,
    intro = input_vec$intro,
    main = input_vec$main,
    company = input_vec$company,
    final = input_vec$final
  )
  return(text_data)
}


## PRINT LETTER---------

# Import the Data and metadata
get_template <- function(language){
  file_name <- "letter.Rmd"
  file_path <- paste(here("markdown_letter", file_name))
  if (file.exists(file_path)){
    return(file_path)
  } else {
    return(NULL)
  }
}

# Import the Data and metadata
copy_sig <- function(project_dir){
  
  dir_path <- file.path(project_dir, "data","meta_data") 
  
  file_list <- list.files(dir_path, pattern = "signature", full.names = TRUE)
  source_file <- file_list[1]
  ext <- getExtension(source_file)
  file_name <-  paste0( "signature", ext)

  destination_file <- here("markdown_letter", file_name)
  file.copy(source_file, destination_file, overwrite = TRUE)
  
  return(file_name)
}

# prints the markdown
print_markdown_letter <- function(template, file_name, header, text){
  rmarkdown::render(
    input = template,
    output_file = file_name,
    params = list(
      header = header,
      text = text
    ),
    clean = T)
}

# copies the cv to the output
copy_letter_output <- function(temp_file, project_dir, job_id){
  destination_path <- paste(project_dir, job_id, sep = "/")
  # Copy the file to the destination + delete old
  res <- file.copy(from = temp_file, to = destination_path, overwrite = TRUE)
  file.remove(temp_file)
  return(res)
}

# makes address text on 1-3 lines
make_address_txt <- function(company_address){

  vec <- strsplit(company_address, "\n", fixed = TRUE)[[1]]
  
  if (length(vec) < 3) {
    vec <- c(vec, "")
  } else {
    vec <- c(vec[1:2], paste(vec[-(1:2)], collapse = ", "))
  }
  
  vec <- vec[nzchar(vec)]
  lst <- setNames(as.list(vec), paste0("company_address_", seq_along(vec)))
  
  if (check_value(lst$company_address_2)){
    lst$company_address_2 <- paste0(lst$company_address_2, " \\\\")
  }
  
  
  return(lst)
}

make_greeting <- function(language = "en"){
  switch(language,
         
         "en" = {"Sincerely yours,"},
         
         "de" = {"Mit freundlichen Grüssen"},
         
         "pt" = {"Atenciosamente,"},
         
         {"Sincerely yours,"}
         
         )
  
}

make_footer <- function(language, name){
  
  switch(language,
         
         "en" = {paste("Written by", name, "personally")},
         
         "de" = {paste("Durch", name, "persönlich verfasst")},
         
         "pt" = {paste("Escrito por", name, "pesoalmente")},
         
         {"Sincerely yours,"}
         
  )
  
  
  
}

# manages the whole printing process
manage_letter_print <- function(user_data, job_data, letter_data, cv_data){

  # # header Data
  header <- letter_data$header
  # copy the picture
  header$signature <- copy_sig(user_data$project_dir)
  header$greeting_line <- make_greeting(job_data$language)
  header$footer <- make_footer(job_data$language, header$name)
  header$color <- clean_color(cv_data$color)
  text <- letter_data$text

  adress <- make_address_txt(text$company_address)
  text <- c(text, adress)
  # text$company_address_2 <- NULL
  # text$company_address_3 <- "fbewrtbwr"
  
  # get the right cv template and copy it to the markdown folder
  template <- get_template(job_data$language)

  # define template and output path
  file_name <- paste0("doc_", cv_data$job_id, "_",tolower(job_data$language),".pdf")

  browser()
  
  # print markdown + copy to jobs folder
  temp_file <- print_markdown_letter(template, file_name, header, text)
  
  # only if success then I make job folder
  if (file.exists(temp_file)){
    res1 <- create_dir(user_data$project_dir, cv_data$job_id)
    res2 <- copy_letter_output(temp_file, user_data$project_dir, cv_data$job_id)
    
    success <- all(res1, res2)
  } else {
    success <- FALSE
  }
  
  extensions <- c("\\.jpg", "\\.jpeg", "\\.log", "\\.png","\\.tex", "\\.pdf")
  clean_directory(directory = paste(here("markdown_letter")), extensions)

  
  if (success){
    showNotification(paste("Letter for", cv_data$job_id, "was created."), type = "message")
    return(TRUE)
  } else {
    showNotification("Some Problem Occurred. Letter not created. Try Again.", type = "warning")
    return(FALSE)
  }
}


#####-------------------- SHINY MODULES UI ----------------------------------#####
MODULE_LETTER_UI <- function(id, params) {
  ns <- NS(id)
  tagList(
    # renders all basic UI elements // hides certain elements
    column(6,offset = 3,
           
           fluidRow(h2("Write you Letter.")),
           tags$hr(),
           # page status
           fluidRow(id = ns("start_ui"), user_sts_page("sts_start", ns = ns, params = params)),
           fluidRow(id = ns("success_ui"), user_sts_page("sts_success", ns, params))%>%shinyjs::hidden(),
           # job form ui elements
           fluidRow(id = ns("ui_form"), letter_ui_form(ns, params)) %>%shinyjs::hidden(),
           # buttons
           fluidRow(id = ns("btrw_start"), btn_line(c("btn_start"),ns = ns, params = params)) %>% shinyjs::hidden(),
           fluidRow(id = ns("btrw_ready"), btn_line(c("btn_back", "btn_print"),ns = ns, params = params))%>%shinyjs::hidden(),
           fluidRow(id = ns("btrw_next"), btn_line(c("btn_reset", "btn_next"),ns = ns, params = params))%>%shinyjs::hidden(),
           tags$br(),
           tags$br()
    )
  )
}



#####-------------------- SERVER PART ----------------------------------#####
MODULE_LETTER_SERVER <- function(id, r_data, r_control, r_comm, params) {
  moduleServer(id,function(input, output, session) {
    
    ##-------------- APERO----------------
    ns <- session$ns
    # creating new Temp Var for transfer inside module // SOME OR ALL WILL COME FROM CENTRALIZED R_ PART
    temp_vals<-reactiveValues(
      check_list = NULL
    )
    
    ##-------------- START AND TAB HANDLING ----------------
    # Sets or Resets initial state or success state depending if i have already user data
    observeEvent(r_control$ready_cv, {

      req(r_control$ready_cv)
      temp_vals$check_list = get_letter_checks()
      r_comm$footer_txt <- letter_reset(session, params, r_data, r_control)
    })

    # restart page
    observeEvent(input$btn_reset,{
      req(r_control$ready_cv)
      temp_vals$check_list = get_letter_checks()
      r_comm$footer_txt <- letter_reset(session, params, r_data, r_control)
    })
    
    # jumps to next tab
    observeEvent(input$btn_next,{r_control$goto_tab <- 4})
    
    # jumps to former tab
    observeEvent(input$btn_back,{r_control$goto_tab <- 2})
    
    # # rendering top text (guiding) // is a UI because changes color
    # output$top_text <- renderUI({r_comm$footer_txt})
    
    ##-------------- INPUT VALUE CHECKER ----------------    
    # Reactive handler of user form information // updates live text
    # This is the reactive which reacts if any of the Variable_selectors has changed or added
    input_listener_d<-reactive({
      req(temp_vals$check_list)
      map(names(temp_vals$check_list), ~ input[[.x]])%>%setNames(names(temp_vals$check_list))
    })%>% debounce(500)
    
    # Reactive live data Checker
    observe({
      req(input_listener_d())
      r_comm$footer_txt  <- Input_Checker(
        input_vec = input_listener_d(),
        check_list = temp_vals$check_list,
        params = params)
    })
    
    ##-------------- AFTER CONFIRMATION HANDLING ----------------

    # PRINT LETTER ----------------

    # On click print, make letter
    observeEvent(input$btn_print, {
      req(input$btn_print)
      req(r_data$user_data)
      req(r_data$job_data)

      show_modal_spinner(session = session, spin = "cube", color = "#112446", text = params$ui_elems$print_wait_txt)
      #r_data$cv_data <- r_data$cv_data
      r_data$letter_data$text <- collect_letter_data(input_listener_d())

      r_data$final <- tryCatch({
        ret <- manage_letter_print(r_data$user_data, r_data$job_data, r_data$letter_data, r_data$cv_data)
        r_control$ready_letter <- TRUE
        ret
      }, error = function(e) {
        showNotification("Something went wrong. Change data and try again.", type = "error")
        NULL
      })
      remove_modal_spinner()
    })
    
    # renders the confirmation ui and goes to next tab
    observeEvent(r_control$ready_letter,{
      req(r_control$ready_letter)
      job <- "get here the job id and path"
      r_comm$footer_txt <- set_ui_success(session = session, params = params, paste("Application", job ,"Successfully created!"))
      r_control$goto_tab <- 0
    })

  })
}