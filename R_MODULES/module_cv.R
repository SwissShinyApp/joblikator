## Module CV (Tab 2)

#####-------------------- UI RELATED FUNCTIONS ----------------------------------#####

# write either a list of params %in% which the value must be or a funciton using x
## ATENTION, THIS LIST MUST CONTAIN ALL IDS FROM THE BELOW TAGLIST, EVEN IF ITS NOT CHECKED (THEN WRITE NULL)
get_cv_checks <- function(){
  list(
    company_name = list(fnc = "nchar(x)>3 & nchar(x)<20", txt = "Company name 1 must be between 3 and 20 characters"),
    job_title = list(fnc = "nchar(x)>5", txt = "Job title must be at least 5 characters"),
    color = list(fnc = "valid_hex_color(x)", txt = "Please provide a valid Hex color, e.g. #2596be."),
    
    highlight_1 = list(fnc = "nchar(x)>5 & nchar(x)<65", txt = "Highlight 1 must be between 5 and 65 characters"),
    highlight_2 = list(fnc = "nchar(x)>5 & nchar(x)<65", txt = "Highlight 2 must be between 5 and 65 characters"),
    highlight_3 = list(fnc = "nchar(x)>5 & nchar(x)<65", txt = "Highlight 3 must be between 5 and 65 characters"),
    prompt_add = NULL,
    temp = NULL
  )
}

# form for inputs
cv_ui_form <- function(ns, params){
  tagList(
    
    # Choose directory
    fluidRow(id = ns("ui_form_2"),
             column(3, btn_line(c("btn_prompt"),ns = ns, params = params), style = "margin-top: 35px;"),
             column(3, btn_line(c("btn_last"),ns = ns, params = params), style = "margin-top: 35px;"),
             column(6, slider_100(ns, "temp", "Creativity")),
             column(12, txt_area_1line(ns, "prompt_add", "Not happy? Refine your Question!")),
             column(12, tags$hr())

    ),
    txt_inp_normal(ns, "company_name", "Company name", plh = "provide the company's name"),
    txt_inp_normal(ns, "job_title", "Job title"),
    color_picker(ns, "color", "CV decoration color"),

   # txt_inp_normal(ns, "color", "CV decoration color"),
    fluidRow(column(12,uiOutput(ns("value_txt") ))),
    tags$hr(),
    txt_area_1line(ns, "highlight_1", "Highlight 1"),
    txt_subline(ns, "default_highlight_1"),
    txt_area_1line(ns, "highlight_2", "Highlight 2"),
    txt_subline(ns, "default_highlight_2"),
    txt_area_1line(ns, "highlight_3", "Highlight 3"),
    txt_subline(ns, "default_highlight_3"),

    tags$hr()
    
  )
} 

get_lang_def_hl <- function(default_highlight, language){
  if (language == "en"){
    list(
      highlight_1 =default_highlight$highlight_1_en,
      highlight_2 = default_highlight$highlight_2_en,
      highlight_3 = default_highlight$highlight_3_en
    )
  }
  else if (language == "de"){
    list(
      highlight_1 = default_highlight$highlight_1_de,
      highlight_2 = default_highlight$highlight_2_de,
      highlight_3 = default_highlight$highlight_3_de
    )
    
  } else {
    list(
      highlight_1 =default_highlight$highlight_1_en,
      highlight_2 = default_highlight$highlight_2_en,
      highlight_3 = default_highlight$highlight_3_en
    )
  }
}



# REnders the ui elements ready
cv_reset <- function(session, params, r_data, r_control, output){

  hl <- get_lang_def_hl(r_data$job_data$default_highlight, r_data$job_data$language)

  updateTextAreaInput(session, "highlight_1", value = hl$highlight_1)
  updateTextAreaInput(session, "highlight_2", value = hl$highlight_2)
  updateTextAreaInput(session, "highlight_3", value = hl$highlight_3)
  # 
  output$default_highlight_1 <- renderUI(make_subline(hl$highlight_1))
  output$default_highlight_2 <- renderUI(make_subline(hl$highlight_2))
  output$default_highlight_3 <- renderUI(make_subline(hl$highlight_3))
  
  # # reset the inputs
  if (isFALSE(r_control$is_job)){
    updateTextInput(session, "company_name", value = "general")
    
  } else {
    updateTextInput(session, "company_name", placeholder = "Inform company name", value = NA)
  }
  updateTextInput(session, "job_title", value = r_data$job_data$default_highlight$position)
  #updateTextInput(session, "color", value = r_data$user_data$default_highlight$color)
  updateTextAreaInput(session, "prompt_add", placeholder = "Refine your question")
  updateSliderTextInput(session, "temp", selected = 40)
  
  colourpicker::updateColourInput(session, "color",  value = r_data$job_data$default_highlight$color)
  
  # reset reactives
  r_data$cv_data = NULL
  r_data$letter_data = NULL
  
  # control reset
  r_control$ready_cv <- FALSE
  r_control$ready_letter <- FALSE

  # returns the text
  set_ui_ready(session = session, params = params, "Here are your Highlights generated by GPT. You can adjust them")
}


#####-------------------- SERVER RELATED FUNCTIONS ----------------------------------#####

## RUN GPT ---------
# writes parameters to json for python
write_jsn_args <- function(query_type, temp, prompt_add, language, has_letter){
  
  # Put all the variables into a list
  params <- list(
    query_type = query_type,
    temp = temp,
    prompt_add = prompt_add,
    language = language,
    has_letter = has_letter
  )
  
  file_path <- here("PY_MODULES", "params.json")
  if (file.exists(file_path)) {
    # Rename the original file
    file.remove(file_path)
  }
  
  # Convert the list to JSON and write it to a file
  write_json(params, file_path)
  return(file.exists(file_path))
}

# checks the return and none successfull replaces by default
def_highlight <- function(default_highlight){

  list(
    job_title = default_highlight$position,
    company_name = "No company name detected",
    highlight = list(
      highlight_1 = default_highlight$highlight_1,
      highlight_2 = default_highlight$highlight_2,
      highlight_3 = default_highlight$highlight_3
    ),
    values = "No values found",
    color = default_highlight$color
  )
}


# checks the return and none successfull replaces by default
check_highlight <- function(data, default_highlight){

  highlight <- list()
  
  # title
  if (check_value(data$title) & !isFALSE(data$title)){
    highlight$job_title <- data$title
    attr(highlight$job_title, "source") <- "GPT"
  } else {
    highlight$job_title <- default_highlight$position
    attr(highlight$job_title, "source") <- "default"
  }
  
  # company
  if (check_value(data$company) & !isFALSE(data$company)){
    highlight$company_name <- data$company
    attr(highlight$company_name, "source") <- "GPT"
  } else {
    highlight$company_name <- "No company name detected"
    attr(highlight$company_name, "source") <- "default"
  }

  # hl 1
  if (check_value(data$highlight$highlight_1) & !isFALSE(data$highlight$highlight_1)){
    highlight$highlight$highlight_1 <- data$highlight$highlight_1
    attr(highlight$highlight$highlight_1, "source") <- "GPT"
  } else {
    highlight$highlight$highlight_1 <- default_highlight$highlight_1
    attr(highlight$highlight$highlight_1, "source") <- "default"
  }
  
  # hl 2
  if (check_value(data$highlight$highlight_2) & !isFALSE(data$highlight$highlight_2)){
    highlight$highlight$highlight_2 <- data$highlight$highlight_2
    attr(highlight$highlight$highlight_2, "source") <- "GPT"
  } else {
    highlight$highlight$highlight_2 <- default_highlight$highlight_2
    attr(highlight$highlight$highlight_2, "source") <- "default"
  }
  
  
  # hl 3
  if (check_value(data$highlight$highlight_3) & !isFALSE(data$highlight$highlight_3)){
    highlight$highlight$highlight_3 <- data$highlight$highlight_3
    attr(highlight$highlight$highlight_3, "source") <- "GPT"
  } else {
    highlight$highlight$highlight_3 <- default_highlight$highlight_3
    attr(highlight$highlight$highlight_3, "source") <- "default"
  }
  
  # values
  vls <- data$values %>% purrr::keep(check_value) %>% 
    purrr::discard(isFALSE) %>% 
    paste(collapse = ", ") 
  
  if (check_value(vls)){
    highlight$values <- vls
    attr(highlight$values, "source") <- "GPT"
  } else {
    highlight$values <- "No values found"
    attr(highlight$values, "source") <- "default"
  }
  
  # color // from sentiment analyis
  if (valid_hex_color(data$color)){
    highlight$color <- data$color
    attr(highlight$color, "source") <- "GPT"
  } else {
    highlight$color <- default_highlight$color
    attr(highlight$color, "source") <- "default"
  }
  return(highlight)
  
}

# makes user message to inform which vars were found
make_usr_msg <- function(cv_data){
  gpts <- cv_data %>%purrr::list_flatten(name_spec = "{inner}",) %>% Filter(function(x) attr(x, "source") == "GPT", .)%>% 
    names() %>% paste(collapse = ", ") %>% gsub("_", " ", .) %>% stringr::str_to_title() 
  
  defs <- cv_data %>%purrr::list_flatten(name_spec = "{inner}",) %>% Filter(function(x) attr(x, "source") == "default", .)%>% 
    names() %>% paste(collapse = ", ") %>% gsub("_", " ", .) %>% stringr::str_to_title()
  
  paste0("Variables identified by GPT: ", gpts, " / Default Variables: ",defs )
  
}

# generates user feedback
generate_notif <- function(cv_data){

  fails <- cv_data %>%purrr::list_flatten(name_spec = "{inner}",) %>% Filter(function(x) attr(x, "source") == "default", .) %>% length()

  if (fails > 1){
    showNotification("GPT responded partially. Some variables are taken from default values", type = "warning")
  } else {
    showNotification("Full success! GPT got all information you need", type = "message")
  }
}

# Updates the UI elements and renders the texts after GPT ran
cv_ui_update <- function(session, params, cv_data, output){

  if (check_if(attr(cv_data$company_name, "source"), "GPT")){
    updateTextInput(session, "company_name", value = as.character(cv_data$company_name))
  } else {
    updateTextInput(session, "company_name",  placeholder = as.character(cv_data$company_name))
  }
  
  # # reset the inputs
  updateTextInput(session, "job_title", value = as.character(cv_data$job_title))
  updateTextInput(session, "color", value = cv_data$color)
  updateTextInput(session, "highlight_1", value = as.character(cv_data$highlight$highlight_1))
  updateTextInput(session, "highlight_2", value = as.character(cv_data$highlight$highlight_2))
  updateTextInput(session, "highlight_3", value = as.character(cv_data$highlight$highlight_3))
  
  if (check_if(attr(cv_data$values, "source"), "GPT")){
    val_txt <- h3(paste("Company values are:", as.character(cv_data$values)), style = "text-align: left; color: #6a1515") 
  } else {
    val_txt <- h3("No company values identified", style = "text-align: left; color: #6F6659")
  }
  print("Company values")
  print(val_txt)
  output$value_txt <- renderUI({val_txt})
  
  
  txt1 <- make_usr_msg(cv_data)
  toptxt <- text_ui(x = 'txt_success', params = params, txt1)
  print("return text")
  print(toptxt)
  return(toptxt)
  
}

# makes the intro section.
mke_phrase <- function(phrase, default){
  if (!isFALSE(phrase)){
    x <- phrase
  } else {
    x <- default
  }
  y <- gsub("\\.", "", x) %>% trimws()
  return(y)
}

make_intro_section <- function(data, letter_data){

  skill <- mke_phrase(data$skill_phrase, letter_data$skill_default)
  personality <- mke_phrase(data$personality_phrase, letter_data$personality_default)
  intro <- letter_data$intro_txt %>% paste0(" ", skill,". ", personality,"." )
  return(intro)
}


make_company_section <- function(data, letter_data){
  if (!isFALSE(data$company_phrase)){
    return(data$company_phrase)
  } else {
    return(letter_data$company_default)
  }
}
  
make_company_address <- function(company){
  
  if (isFALSE(company)){
    return(NA)
  } else {
    
    return(company)
  }
}  

clean_color <- function(color){
  color <- as.character(color)
  if (valid_hex_color(color)){
    return(gsub("[^a-zA-Z0-9]", "", color) )
  } else {
    return("000000")
  }
  
}

check_letter <- function(data, user_data, job_data,  cv_data){

  letter_data <- job_data$letter_data
  
  text <- list(
    company_address = make_company_address(data$company),
    job_title = as.character(cv_data$job_title),
    concern = letter_data$concern_txt,
    intro = make_intro_section(data, letter_data),
    main = letter_data$main_txt,
    company = make_company_section(data, letter_data),
    final = letter_data$final_txt
  )
  header <- list(
    name = user_data$personal_data$name,
    color = ifelse(valid_hex_color(data$color) , clean_color(data$color),clean_color(cv_data$color)),
    address = user_data$personal_data$address,
    email = user_data$personal_data$email
  )
  
  return(list(header = header, text = text))

}

default_letter <- function(user_data, job_data,  cv_data){
  letter_data <- job_data$letter_data
  
  text <- list(
    company_address = NA,
    job_title = as.character(cv_data$job_title),
    concern = letter_data$concern_txt,
    intro = make_intro_section(list(skill_phrase = FALSE, personality_phrase = FALSE), letter_data),
    main = letter_data$main_txt,
    company = make_company_section(list(company_phrase = FALSE), letter_data),
    final = letter_data$final_txt
  )
  
  header <- list(
    name = user_data$personal_data$name,
    color = clean_color(cv_data$color),
    address = user_data$personal_data$address,
    email = user_data$personal_data$email
    
  )
  
  return(list(header = header, text = text))
  
}


# Calls the python GPT-Highlights interface
run_gpt <- function(input_vec, job_data, query_type = "initiate") {

  # stores the job desc
  query_type = "initiate"
  prompt_add = input_vec$prompt_add
  temp <- as.integer(input_vec$temp) %>% magrittr::divide_by(50)
  openai_api_key <- job_data$openai_api_key
  has_letter <- job_data$has_letter
  language <- job_data$language
  # cv_type <- job_data$cv_type
  res <- write_jsn_args(query_type, temp, prompt_add, language, has_letter)
  if (!res){return(FALSE)}
  
  hl_path <- system2("python", c("PY_MODULES/gpt_interface.py", openai_api_key), stdout = TRUE)
  data <- fromJSON(hl_path[[1]])
  #data <- fromJSON(here('PY_MODULES/highlight.json'))

  return(data)
}


# Calls the python GPT-Highlights interface
rep_last <- function() {
  return(fromJSON(here('PY_MODULES/highlight.json')))
}


# Calls the python GPT-Highlights interface
parse_gpt_result <- function(data, user_data, job_data) {

  hl <- get_lang_def_hl(job_data$default_highlight, job_data$language) %>%
    modifyList(job_data$default_highlight)
  
  data$color <- paste0("#", data$color )

  if (isFALSE(data)){
    cv_data <- def_highlight(hl)
    letter_data <- default_letter(user_data, job_data,  cv_data)

  } else {
    cv_data <- check_highlight(data, hl)

    letter_data <- check_letter(data, user_data, job_data,  cv_data)
    
  }
  
  # Read the JSON file
  generate_notif(cv_data)
  
  return(list(cv_data = cv_data, letter_data = letter_data))
}

## CAPTURE VALUES ---------

# adds an increment if string name has already a number after _, ow starts enumerating with _1
add_increment <- function(base_string){

  # Extract the part after the last underscore
  suffix <- sub(".+_", "", base_string)
  
  # Check if the suffix can be converted to numeric
  if (!is.na(as.numeric(suffix))) {
    # Increment the numeric suffix by 1
    new_suffix <- as.numeric(suffix) + 1
    return(paste0(sub("_[^_]+$", "", base_string), "_", new_suffix))
  } else {
    # Set the suffix to 1
    new_suffix <- 1
    return(paste0(base_string, "_", new_suffix))
  }
  
  # Concatenate the new suffix with the base string

}

# random name
make_hex_id <- function(){
  hex_digits <- c(0:9, letters[1:6])
  return(paste0(sample(hex_digits, 10, replace = TRUE), collapse = ""))
}

# create an job id name from company name // RECURSIVE
compname_to_jobid <- function(company_name, all_job){

  x <- gsub("[^a-zA-Z0-9 _]", "", company_name) %>%
    gsub(" ", "_", .) %>%
    tolower()
  
  if (!check_value(x)){return(make_hex_id())}
  
  if (x %in% all_job$job_id){
    compname_to_jobid(add_increment(x), all_job)
  } else {
    return(x)
  }
}

# finally collect the inputs for cv
collect_cv_data <- function(input_vec, cv_data, all_job){

  new_lst <- list(
    job_title = input_vec$job_title,
    company_name = input_vec$company_name,
    color = input_vec$color,
    highlight = list(
      highlight_1 = input_vec$highlight_1,
      highlight_2 = input_vec$highlight_2,
      highlight_3 = input_vec$highlight_3
    )
  )
  cv_data <- new_lst
  
  #cv_data <- cv_data %>% modifyList(new_lst)
  
  cv_data$job_id <- compname_to_jobid(cv_data$company_name, all_job)
  
  return(cv_data)
}


## PRINT CV ---------

# cleans the highlight text for latex
prepare_highlights <- function(highlight, language = "en"){
 
   # replace ands
  clean <- function(x){
    gsub("&", "\\&", x, fixed = TRUE)
  }
  highlight <- map(highlight, ~ clean(.x))
  # replace
  
  highlight$color <- clean_color(highlight$color)
  # if (valid_hex_color(highlight$color)){
  #   highlight$color <-  gsub("[^a-zA-Z0-9]", "", highlight$color) 
  # } else {
  #   highlight$color <- "000000"
  # }
  highlight$hl_title <- switch(language,
                               
                               "en" = {  if (tolower(highlight$company_name) != "general" & check_value(highlight$company_name)){
                                 paste("Why I'm the right fit for", highlight$company_name)
                               } else {
                                 paste("What distinguishes me")
                               }},
                               
                               "de" = {  if (tolower(highlight$company_name) != "general" & check_value(highlight$company_name)){
                                 paste("Warum ich die richtige Wahl fÃ¼r", highlight$company_name, "bin")
                               } else {
                                 paste("Was mich auszeichnet")
                               }},
                               
                               "pt" = {  if (tolower(highlight$company_name) != "general" & check_value(highlight$company_name)){
                                 paste("Why I'm the right fit for", highlight$company_name)
                               } else {
                                 paste("What distinguishes me")
                               }},
                               
                               {}
                               
                               
                               )

  return(highlight)
}

# parse phone number
parse_phone <- function(x){

  if (is.na(as.numeric(x))){
    string <- gsub("[^0-9]", "", x) %>% as.character()
  } else {
    y <- as.numeric(x) %>% format(scientific = FALSE) %>% as.character()
    string <- gsub("[^0-9]", "", y)
  }

  
  n<- nchar(string)
  x<-c(2,2,3)
  y <- (n-sum(x)) / 2
  group_lengths <- c(x, rep(2, y)) %>% rev()
  # Create an empty vector to store the groups
  groups <- character(length(group_lengths))
  
  # Iterate over each group length and extract the corresponding substring
  start_index <- 1
  for (i in seq_along(group_lengths)) {
    end_index <- start_index + group_lengths[i] - 1
    groups[i] <- substr(string, start_index, end_index)
    start_index <- end_index + 1
  }
  
  # Combine the groups with spaces
  result <- trimws(paste(groups, collapse = " "))
  return(result)
}

calculate_birthday <- function(birthday, language){

  # prep birthday
  if (check_value(as.POSIXct(birthday, format = "%d.%m.%Y"))){
    # possible_formats <- guess_formats(birthday, "dmy")
    # bd <- parse_date_time(birthday, orders = possible_formats) %>% as.POSIXct()
    # 
    bd <- parse_time_format(birthday)
    
    comp <- switch(language, "en" = "years", "de" = "Jahre", "pt" = "anos")
    
    delta <- as.integer(difftime(Sys.time(), bd, units = "days") / 365.25) %>%
      paste0(birthday," (", ., " ",comp,")")
    
  } else {
    birthday <- NULL
  }
  

}

# prepares and calculates values to print in header
prepare_header <- function(personal_data, language){

  personal_data$birthday <- calculate_birthday(personal_data$birthday, language)
  
  # addressline
  personal_data$address_line <- personal_data %>% 
    keep_by_name(c("address", "birthday", "private")) %>% 
    purrr::keep(check_value) %>% paste(collapse = " | ")
  

  personal_data$phone <- parse_phone(personal_data$phone)
  personal_data <- personal_data %>% keep_by_name(c("name","phone", "address_line", "email","www","github","linkedin","private","profilpic"))

  return(personal_data)
}

# some areas need grouping
group_skills <- function(skills){
  # group the skills if i have
  skills <- skills %>% drop_na()
  order_vector <- skills$area %>% unique()
  skills %>% group_by(area) %>% summarise(skill = paste(skill, collapse = ", ")) %>%
    arrange(match(area, order_vector))
}

# makes an latex icon link from a link
make_icn_link <- function(link, ...){

  if (!check_value(link)){return("")}
  icn <- switch(sub("^https?://([^/]+)/.*", "\\1", link),
         "github.com" = "faGithub",
         "youtu.be" = "faYoutube",
         "docs.google.com" = "file-word",
         "google.com" = "google",
         "faGlobe")
  
  return(paste0("\\href{",link,"}{\\",icn,"}"))
}

# imports one csv file and prepares it
import_csv <- function(file_name, path){
  
  #file_name <- "projects_datascience_en.csv"
  file_path <- paste(path, file_name, sep = "/")
  X <- read_csv(file_path)
  
  if ("link" %in% colnames(X)){
    X <- X %>% mutate(link = pmap_chr(., .f = make_icn_link))
  }
  
  if (grepl("skills", file_name)){
    X <- group_skills(X)
  }
  return(X)
}

# import all data
import_data <- function(project_dir, language, cv_type){
  # get skills
  path <- paste(project_dir, "data", "cv_data", cv_type, sep = "/")

  # filter the files to import
  files <- list.files(path, full.names = FALSE, include.dirs = FALSE) %>% 
    purrr::keep(~grepl("\\.csv$", .x)) %>%  # filter all csv
    purrr::keep(~grepl(paste0("_", tolower(language)), .x)) %>% # filter all language
    purrr::keep(~grepl(paste0("_", tolower(cv_type)), .x)) # filter by job
  
  # define the names
  names <- files %>% purrr::map_chr(~sub("_.*", "", .x))
  
  # import the data
  data <- files %>% map( ~import_csv(.x, path)) %>% setNames(names)

  return(data)
}

# Import the Data and metadata
copy_template <- function(project_dir, language, cv_type){
  
  file_name <- paste0("CV_", cv_type,"_", tolower(language),".Rmd")
  source_file <- paste(project_dir, "data", "cv_data", cv_type, file_name, sep = "/")
  destination_file <- paste(here("markdown_cv", "CV.Rmd"))
  file.copy(source_file, destination_file, overwrite = TRUE)
  
  return(destination_file)
}

# Import the Data and metadata
copy_pic <- function(project_dir, profilpic){
  
  ext <- getExtension(profilpic)
  file_name <-  paste0( "me", ext)
  source_file <- file.path(project_dir, "data", "meta_data", profilpic)
  
  destination_file <- here("markdown_cv", file_name)
  file.copy(source_file, destination_file, overwrite = TRUE)
  
  return(file_name)
}

# prints the markdown
print_markdown <- function(template, file_name, header, data, highlight){
  rmarkdown::render(
    input = template,
    output_file = file_name,
    params = list(
      header = header,
      data = data,
      highlight = highlight
    ),
    clean = T)
}

# copies the cv to the output
copy_cv_output <- function(temp_file, project_dir, job_id){
  destination_path <- paste(project_dir, job_id, sep = "/")
  # Copy the file to the destination + delete old
  res <- file.copy(from = temp_file, to = destination_path, overwrite = TRUE)
  file.remove(temp_file)
  return(res)
}

# copies the diplomas to output
copy_appendix <- function(project_dir, job_id){
  source_path <- paste(project_dir, "data", "appendix", sep = "/")
  destination_path <- paste(project_dir, job_id, sep = "/")
  files <- list.files(source_path, full.names = TRUE)
  # Copy each file to the destination directory
  for (file in files) {
    res <- file.copy(from = file, to = destination_path, overwrite = TRUE)
  }
  return(res)
}

# procedure to open an new job and store files in folder and store it in DB
create_new_job <- function(temp_file, user_data,job_data, highlight){

  res0 <- file.exists(temp_file)
  if (!res0){return(list(all_job = user_data$all_job, job_status = user_data$job_status,  success = FALSE))}
  
  # creater folder + copy
  res1 <- create_dir(user_data$project_dir, highlight$job_id)
  res2 <- copy_cv_output(temp_file, user_data$project_dir, highlight$job_id)
  res3 <- copy_appendix(user_data$project_dir, highlight$job_id)
  res_alljob <- FALSE
  res_jobsts <- FALSE
  # store the job
  if (all(res1, res2, res3)){
    all_job <-  user_data$all_job %>% 
      add_case(
        ## metadata
        job_id = highlight$job_id,
        job_link = job_data$job_link,
        cv_type = job_data$cv_type,
        language = job_data$language,
        #direct = as.integer(job_data$direct),
        #source = as.integer(job_data$source),
        has_letter = as.integer(job_data$has_letter),
        # cv data
        company_name = highlight$company_name,
        job_title = highlight$job_title,
        color = highlight$color,
        highlight_1 = highlight$highlight_1,
        highlight_2 = highlight$highlight_2,
        highlight_3 = highlight$highlight_3,
      ) %>% dplyr::select(any_of(c("job_id", "job_link","cv_type","language","direct","source","has_letter","company_name","job_title","color","highlight_1","highlight_2","highlight_3")))
    
    res_alljob <- save_csv_overwrite(all_job, file.path(user_data$project_dir, "data", "meta_data"), "all_job.csv")
    
  }
  
  # save job status
  if (res_alljob){
    job_status <- user_data$job_status %>% 
      add_case(job_id = highlight$job_id,
               time_stamp = Sys.Date(),
               status = "applied")
    res_jobsts <- save_csv_overwrite(job_status, file.path(user_data$project_dir, "data", "meta_data"), "job_status.csv")
  }
  
  if (all(res_alljob, res_jobsts)) {
    return(list(all_job = all_job, job_status = job_status, success = TRUE))
  } else {
    return(list(all_job = user_data$all_job, job_status = user_data$job_status,  success = FALSE))
  }
}


# manages the whole printing process
manage_cv_print <- function(user_data, job_data, cv_data){

  # cleans highlights for latex
  highlight <- cv_data %>% purrr::flatten() %>% prepare_highlights(job_data$language)

  # header Data
  header <- prepare_header(user_data$personal_data, job_data$language)

  # main body data
  data <- import_data(user_data$project_dir, job_data$language, job_data$cv_type)

  # get the right cv template and copy it to the markdown folder
  template <- copy_template(user_data$project_dir, job_data$language, job_data$cv_type)
  # copy the picture
  header$profilpic <- copy_pic(user_data$project_dir, header$profilpic)
  
  # define template and output path
  file_name <- paste0("cv_", highlight$job_id, "_",tolower(job_data$language),".pdf")

  # print markdown + copy to jobs folder
  temp_file <- print_markdown(template, file_name, header, data, highlight)
  
  ret <- create_new_job(temp_file, user_data, job_data, highlight)
  success <- ret$success

  extensions <- c("\\.jpg", "\\.jpeg", "\\.log", "\\.png","\\.tex", "\\.pdf")
  clean_directory(directory = paste(here("markdown_cv")), extensions)

  if (success){
    showNotification(paste("CV for", highlight$job_id, "was created."), type = "message")
    return(ret)
  } else {
    showNotification("Some Problem Occurred. CV not created. Try Again.", type = "warning")
    return(ret)
  }
  
}

#####-------------------- SHINY MODULES UI ----------------------------------#####
MODULE_CV_UI <- function(id, params) {
  ns <- NS(id)
  tagList(
    # renders all basic UI elements // hides certain elements
    column(6,offset = 3,
           
           fluidRow(h2("Adjust your CV")),
           tags$hr(),
           # page status
           fluidRow(id = ns("start_ui"), user_sts_page("sts_start", ns = ns, params = params)),
           fluidRow(id = ns("success_ui"), user_sts_page("sts_success", ns, params))%>%shinyjs::hidden(),
           # job form ui elements
           fluidRow(id = ns("ui_form"), cv_ui_form(ns, params)) %>%shinyjs::hidden(),
           # buttons
           fluidRow(id = ns("btrw_start"), btn_line(c("btn_start"),ns = ns, params = params)) %>% shinyjs::hidden(),
           fluidRow(id = ns("btrw_ready"), btn_line(c("btn_back", "btn_print"),ns = ns, params = params))%>%shinyjs::hidden(),
           fluidRow(id = ns("btrw_next"), btn_line(c("btn_reset", "btn_next"),ns = ns, params = params))%>%shinyjs::hidden(),
           tags$br(),
           tags$br()
    )
  )
}



#####-------------------- SERVER PART ----------------------------------#####
MODULE_CV_SERVER <- function(id, r_data, r_control, r_comm, params) {
  moduleServer(id,function(input, output, session) {
    
    ##-------------- APERO----------------
    ns <- session$ns
    # creating new Temp Var for transfer inside module // SOME OR ALL WILL COME FROM CENTRALIZED R_ PART
    temp_vals<-reactiveValues(
      check_list = NULL,
      parse_data = NULL,
      data = NULL
    )
    
    ##-------------- START AND TAB HANDLING ----------------
    # Sets or Resets initial state or success state depending if i have already user data
    observeEvent(r_control$ready_job, {
      req(r_control$ready_job)
      temp_vals$check_list = get_cv_checks()
      r_comm$footer_txt <- cv_reset(session, params, r_data, r_control, output)
    })

    # restart page
    observeEvent(input$btn_reset,{
      req(r_control$ready_job)
      temp_vals$check_list = get_cv_checks()
      r_comm$footer_txt <- cv_reset(session, params, r_data, r_control, output)
    })
    
    # jumps to next tab
    observeEvent(input$btn_next,{r_control$goto_tab <- 3})
    
    # jumps to former tab
    observeEvent(input$btn_back,{r_control$goto_tab <- 1})
    
    # # rendering top text (guiding) // is a UI because changes color
    # output$top_text <- renderUI({r_comm$footer_txt})
    
    ##-------------- INPUT VALUE CHECKER ----------------    
    # Reactive handler of user form information // updates live text
    # This is the reactive which reacts if any of the Variable_selectors has changed or added
    input_listener_d<-reactive({
      req(temp_vals$check_list)
      map(names(temp_vals$check_list), ~ input[[.x]])%>%setNames(names(temp_vals$check_list))
    })%>% debounce(500)
    
    # Reactive live data Checker
    observe({
      req(input_listener_d())
      r_comm$footer_txt  <- Input_Checker(
        input_vec = input_listener_d(),
        check_list = temp_vals$check_list,
        params = params)
    })
    
    ##-------------- AFTER CONFIRMATION HANDLING ----------------
    
    # show // hide the ui parts depending on is job or not
    observeEvent(r_control$is_job, {

      req(r_control$ready_user)
      if (isFALSE(r_control$is_job)){
        updateTextInput(session, "company_name", value =  "general")
        shinyjs::hide("company_name")
        shinyjs::hide("ui_form_2")
      } else {
        shinyjs::show("company_name")
        shinyjs::show("ui_form_2")
        updateTextInput(session, "company_name", placeholder = "Inform company name", value = NA)
      }
    })

    
    # REACTIVE HANDLER GPT ----------------

    
    
    # observeEvent(input$btn_prompt, {
    #   # entry stuff
    #   req(input$btn_prompt)
    #   req(r_data$user_data)
    #   req(r_data$job_data)
    #   show_modal_spinner(session = session, spin = "double-bounce", color = "#112446", text = params$ui_elems$ai_wait_txt)
    #   
    #   browser()
    #   result <- reactiveVal(NULL)
    #   input_vec <- input_listener_d()
    #   
    #   session$doAsync()
    #   
    #   # Start the long-running process in a separate background session
    #   session$doAsync({
    #     #1+1
    #     # Set a timeout of 5 seconds
    #     # timeout <- 5
    #     # start_time <- Sys.time()
    #     # 
    #     # # Call the long-running process function and store the result
    #     # data <- tryCatch({
    #     #   run_gpt(input_vec = input_vec, job_data = r_data$job_data)
    #     # }, error = function(e) {
    #     #   showNotification("GPT takes too long...using default values.", type = "warning")
    #     #   list(FALSE)  # Return NULL in case of an error
    #     # })
    #     
    #     # # Calculate the elapsed time
    #     # elapsed_time <- difftime(Sys.time(), start_time, units = "secs")
    #     # 
    #     # # Check if the process timed out
    #     # if (elapsed_time >= timeout) {
    #     #   # Handle timeout: populate the result with alternative data
    #     #   data <- list(FALSE)  # Assuming the alternative data is an empty list
    #     # }
    #     # 
    #     # Update the result with the data
    #     #result(data)
    #   })
    #   
    #   # remove_modal_spinner()
    #   # browser()
    #   # 
    #   # # Access the result outside of the observeEvent block
    #   # observe({
    #   #   if (!is.null(result())) {
    #   #     data <- result()
    #   #     # Perform further processing on "data"
    #   #     # ...
    #   #     
    #   #     r_data$cv_data <- ret$cv_data
    #   #     r_data$letter_data <- ret$letter_data
    #   #   }
    #   # })
    # })
    # 

    # On click prompt, run GPT
    observeEvent(input$btn_last, {
      # entry stuff
      req(input$btn_last)
      req(r_data$user_data)
      req(r_data$job_data)
      temp_vals$data <- tryCatch({
        rep_last()
      }, error = function(e) {
        FALSE  # Return NULL in case of an error
      })
      temp_vals$parse_data <- sample(1:100000, 1)
    })
    
 
    # On click prompt, run GPT
    observeEvent(input$btn_prompt, {
      # entry stuff
      req(input$btn_prompt)
      req(r_data$user_data)
      req(r_data$job_data)
      show_modal_spinner(session = session, spin = "double-bounce", color = "#112446", text = params$ui_elems$ai_wait_txt)

      input_vec = input_listener_d()

      temp_vals$data <- tryCatch({
        run_gpt(input_vec = input_vec, job_data = r_data$job_data)
      }, error = function(e) {
        showNotification("GPT takes too long...using default values.", type = "warning")
        FALSE  # Return NULL in case of an error
      })
      remove_modal_spinner()
      temp_vals$parse_data <- sample(1:100000, 1)
    })

    # parses the result
    observeEvent(temp_vals$parse_data, {

      req(temp_vals$parse_data)

      data <- temp_vals$data
      ret <- parse_gpt_result(data, r_data$user_data, r_data$job_data)

      r_data$cv_data = ret$cv_data
      r_data$letter_data = ret$letter_data

    })
    # 
    # Updates the inputs 
    observe({
      req(r_data$cv_data)
      r_comm$footer_txt <- cv_ui_update(session = session, params = params,cv_data = r_data$cv_data, output = output)
    })

    # PRINT CV ----------------

    # On click print, make cv
    observeEvent(input$btn_print, {
      req(input$btn_print)
      req(r_data$user_data)
      req(r_data$job_data)

      show_modal_spinner(session = session, spin = "cube", color = "#112446", text = params$ui_elems$print_wait_txt)
      #r_data$cv_data <- r_data$cv_data
      r_data$cv_data <- collect_cv_data(input_listener_d(), r_data$cv_data, r_data$user_data$all_job)

      r_control$ready_cv <- tryCatch({
        ret <- manage_cv_print(r_data$user_data, r_data$job_data, r_data$cv_data)
        r_data$user_data$all_job <- ret$all_job
        r_data$user_data$job_status <- ret$job_status
        ret$success
      }, error = function(e) {
        showNotification("Something went wrong. Change data and try again.", type = "error")
        FALSE
      })


      remove_modal_spinner()
    })

    # renders the confirmation ui and goes to next tab
    observeEvent(r_control$ready_cv,{
      req(r_control$ready_cv)
      job <- "get here the job id and path"
      r_comm$footer_txt <- set_ui_success(session = session, params = params, paste("CV for", "job" ,"was printed!"))

      if (isTRUE(r_control$has_letter)){
        r_control$goto_tab <- 3
      } else {
        r_control$goto_tab <- 0
      }

    })

  })
}